package nntp

import "fmt"

// implements the algorithm from http://www.jwz.org/doc/threading.html

// Tree-structured wrapper around FormattedArticle.
type Container struct {
	Article             FormattedArticle // underlying Article
	Parent, Child, Next *Container       // link structure (threaded tree)
}

type idTable map[MessageId]*Container

var id_table idTable

// Threads articles according to the algorithm from
// http://www.jwz.org/doc/threading.html; see also
// https://raw.github.com/kedorlaomer/loread/master/threading.txt
func Thread(articles []FormattedArticle) []*Container {
	id_table = make(idTable)

    // 1. rough threading
	for _, message := range articles {
		// A. insert to id_table
		container := &Container{
			Article: message,
		}

		id_table[message.Id] = container
	}

	// The original algorithm says here that steps 1A, 1B and 1C
	// should be performed in the same loop (for each message),
	// but using different loops seems to be easier.
	for _, message := range articles {
		// B. link together what belongs together according to
		// message.References
		if len(message.References) > 1 {
			for i := len(message.References) - 2; i >= 0; i-- {
				id1 := message.References[i+1]
				id2 := message.References[i]
				c1 := containerById(id1)
				c2 := containerById(id2)

				// insert a link c1 → c2
				if c1.Parent == nil && mayLink(c1, c2) {
					c1.Parent = c2
				}
			}
		}
	}

	for _, container := range id_table {
		// C. set message's parent.
		refs := container.Article.References
		if len(refs) > 0 {
			// parent, according to References
			realParent := containerById(refs[0])
			if container.Parent == nil {
				container.Parent = realParent
			}
		}
	}

	// Now, messages are linked according to parents. Insert
	// child links.
	for _, container := range id_table {
		if Parent := container.Parent; Parent != nil && Parent.Child == nil {
			Parent.Child = container
		}
	}

	// Children of the same parent should get linked via the
	// next pointer.
	for _, container := range id_table {
		if Parent := container.Parent; Parent != nil {
			Child := Parent.Child
			// If container is in the list of child→next→next→…,
			// we mustn't insert it again.
			mayInsert := Child != container
			for Child.Next != nil && mayInsert {
				mayInsert = mayInsert && Child != container
				Child = Child.Next
			}

			if mayInsert {
				Child.Next = container
			}
		}
	}

	// 2. root set
	rv := []*Container{}

	for _, container := range id_table {
		if container.Parent == nil {
			println(container.Article.Subject)
			rv = append(rv, container)
		}
	}

	for _, c := range rv {
		printContainers(c)
	}

    // 3.
    id_table := nil

    // 4. prune empty containers
    for _, container 

	return rv
}

// id_table[id] may be nil, but we want an empty container
// instead.
func containerById(id MessageId) *Container {
	rv := id_table[id]
	if rv == nil {
		return &Container{}
	}

	return rv
}

// Is c2 reachable from c1? FIXME: Do we need a graph traversal?
func (c1 *Container) reachable(c2 *Container) bool {
	// Breadth-first traversal of graph structure generated by
	// edges parent, child, next.
	visited := make(map[*Container]bool)
	q := NewQueue()
	q.Enqueue(c1)

	for !q.Empty() {
		if c := q.Dequeue().(*Container); c != nil && !visited[c] {
			visited[c] = true
			q.Enqueue(c.Parent)
			q.Enqueue(c.Child)
			q.Enqueue(c.Next)
			if c == c2 { // c2 is reachable
				return true
			}
		}
	}

	return false
}

// Is adding a link between c1 and c2 allowed?
func mayLink(c1, c2 *Container) bool {
	return !c1.reachable(c2) && !c2.reachable(c1)
}

// for debugging: displays the link structure of c
func printContainers(c *Container) {
	printContainersRek(c, 0)
}

func printContainersRek(c *Container, depth int) {
	if depth > 0 {
		for i := 0; i < depth; i++ {
			fmt.Print("•")
		}
	}

	fmt.Println(c.Article.Subject)

	for c2 := c.Child; c2 != nil; c2 = c2.Next {
		printContainersRek(c2, depth+1)
	}
}
